use std::process::Command;

fn main() {
    // ensure man page file exists for include_bytes!
    // in CI, the real content is generated by `cargo run --bin generate-man`
    // before tests run. locally, this creates an empty placeholder.
    let man_dir = std::path::Path::new("man");
    let man_file = man_dir.join("cwm.1");
    if !man_file.exists() {
        std::fs::create_dir_all(man_dir).ok();
        std::fs::write(&man_file, b"").ok();
    }
    println!("cargo:rerun-if-changed=man/cwm.1");

    // compile spotlight stub executable
    compile_spotlight_stub();

    // get git commit hash (with fallback for non-git environments like Docker)
    let (commit, short_commit, timestamp, dirty) = get_git_info();

    fn get_git_info() -> (String, String, String, bool) {
        // try to get git commit hash
        let commit = match Command::new("git").args(["rev-parse", "HEAD"]).output() {
            Ok(output) if output.status.success() => String::from_utf8(output.stdout)
                .unwrap_or_default()
                .trim()
                .to_string(),
            _ => "unknown".to_string(),
        };

        // get short commit hash
        let short_commit = if commit.len() >= 8 {
            commit[..8].to_string()
        } else {
            commit.clone()
        };

        // get commit timestamp
        let timestamp = match Command::new("git")
            .args(["log", "-1", "--format=%ct"])
            .output()
        {
            Ok(output) if output.status.success() => String::from_utf8(output.stdout)
                .unwrap_or_default()
                .trim()
                .to_string(),
            _ => "0".to_string(),
        };

        // check if working directory is dirty
        let dirty = match Command::new("git").args(["status", "--porcelain"]).output() {
            Ok(output) if output.status.success() => !output.stdout.is_empty(),
            _ => false,
        };

        (commit, short_commit, timestamp, dirty)
    }

    // set environment variables for compilation
    println!("cargo:rustc-env=GIT_COMMIT={}", commit);
    println!("cargo:rustc-env=GIT_COMMIT_SHORT={}", short_commit);
    println!("cargo:rustc-env=GIT_TIMESTAMP={}", timestamp);
    println!("cargo:rustc-env=GIT_DIRTY={}", dirty);

    // only rerun if .git/HEAD exists
    if std::path::Path::new(".git/HEAD").exists() {
        println!("cargo:rerun-if-changed=.git/HEAD");
    }

    // build date
    let build_date = chrono::Utc::now().to_rfc3339();
    println!("cargo:rustc-env=BUILD_DATE={}", build_date);

    // github repo from environment or default
    let repo = std::env::var("CWM_GITHUB_REPO")
        .unwrap_or_else(|_| "taulfsime/cool-window-manager".to_string());
    println!("cargo:rustc-env=GITHUB_REPO={}", repo);

    // release channel from environment or default to dev
    let channel = std::env::var("RELEASE_CHANNEL").unwrap_or_else(|_| "dev".to_string());
    println!("cargo:rustc-env=RELEASE_CHANNEL={}", channel);
}

/// compiles the spotlight stub executable for embedding in the binary
fn compile_spotlight_stub() {
    let stub_source = std::path::Path::new("scripts/spotlight_stub.c");
    let assets_dir = std::path::Path::new("assets");
    let stub_output = assets_dir.join("spotlight_stub");

    println!("cargo:rerun-if-changed=scripts/spotlight_stub.c");

    // ensure assets directory exists
    std::fs::create_dir_all(assets_dir).ok();

    // check if source exists
    if !stub_source.exists() {
        // create empty placeholder for initial compilation
        if !stub_output.exists() {
            std::fs::write(&stub_output, b"").ok();
        }
        return;
    }

    // get target architecture
    let target_arch = std::env::var("CARGO_CFG_TARGET_ARCH").unwrap_or_default();
    let arch_flag = match target_arch.as_str() {
        "x86_64" => "x86_64",
        "aarch64" => "arm64",
        _ => "arm64", // default to arm64 for Apple Silicon
    };

    // compile directly with clang
    let compile_status = Command::new("clang")
        .args([
            "-arch",
            arch_flag,
            "-O2",
            "-o",
            stub_output.to_str().unwrap(),
            stub_source.to_str().unwrap(),
        ])
        .status();

    match compile_status {
        Ok(status) if status.success() => {
            // compilation succeeded
        }
        _ => {
            // create empty placeholder if compilation fails
            if !stub_output.exists() {
                std::fs::write(&stub_output, b"").ok();
            }
            eprintln!("Warning: Failed to compile spotlight stub, using placeholder");
        }
    }
}
